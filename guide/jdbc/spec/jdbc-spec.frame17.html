<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title></title>
</head>
<body bgcolor=#ffffff>

<table width=600><tr>
<td><font size=-1>
<a href="jdbc-spec.frame.html">Contents</a>  | <a href="jdbc-spec.frame16.html">Prev</a>  | <a href="jdbc-spec.frame18.html">Next</a>
</font></td><td align=right><i>JDBC<sup><font size=-2>TM</font></sup> Guide: Getting Started</i></td>
</tr></table>
<hr>
<br>
 

<a name="20043"></a>
<h2>Appendix C:  Implementation notes</h2>


<a name="25175"></a>
<h3>C.1 	  &nbsp; &nbsp; ResultSet lookups by method name</h3>
<a name="25231"></a>
Here is some specimen code that implements the ResultSet.findColumn and (for example) ResultSet.getString
using ResultSetMetaData.
<p>
<pre><code>private java.util.Hashtable s2c;						// Maps strings to column indexes
</code></pre>
<pre><code>private ResultSetMetaData md;						// Our metadata object.
</code></pre>
<pre><code>
</code></pre>
<pre><code>public synchronized int findColumn(String columnName)
</code></pre>
<pre><code>							throws SQLException {
</code></pre>
<pre><code>	// Make a mapping cache if we don't already have one.
</code></pre>
<pre><code>	if (md == null) {
</code></pre>
<pre><code>	    md = getMetaData();
</code></pre>
<pre><code>	    s2c = new java.util.Hashtable();
</code></pre>
<pre><code>	}
</code></pre>
<pre><code>	// Look for the mapping in our cache.
</code></pre>
<pre><code>	Integer x = (Integer)s2c.get(columnName);
</code></pre>
<pre><code>	if (x != null) {
</code></pre>
<pre><code>	    return (x.intValue());
</code></pre>
<pre><code>	}
</code></pre>
<pre><code>	// OK, we'll have to use metadata.
</code></pre>
<pre><code>	for (int i = 1; i &lt; md.getColumnCount(); i++) {
</code></pre>
<pre><code>	    if (md.getColumnName(i).equalsIgnoreCase(columnName)) {
</code></pre>
<pre><code>		// Success!  Add an entry to the cache.
</code></pre>
<pre><code>		s2c.put(columnName, new Integer(i));
</code></pre>
<pre><code>		return (i);
</code></pre>
<pre><code>	    }
</code></pre>
<pre><code>	}
</code></pre>
<pre><code>	throw new SQLException("Column name not found", "S0022");
</code></pre>
<pre><code>}
</code></pre>
<pre><code>
</code></pre>
<pre><code>// now the individual get-by-column-name methods are easy:
</code></pre>
<pre><code>
</code></pre>
<pre><code>public String getString(String columnName) throws SQLException {
</code></pre>
<pre><code>	return (getString(findColumn(columnName)));
</code></pre>
<pre><code>}
</code></pre>
<a name="25216"></a>

<p>

<a name="25211"></a>
<h3>C.2 	  &nbsp; &nbsp; Object finalization</h3>
<a name="37454"></a>
Applets are advised to call "close" on the various JDBC objects such as Statement, ResultSet, 
Connection, when they are done with them. However, some applets will forget and some applets
may get killed before they can close these objects.
<p>
<a name="37462"></a>
If JDBC drivers have state associated with JDBC objects that needs to get explicitly cleared up, 
then they should take care to provide "finalize" methods. The garbage collector will call these 
finalize methods when the objects are found to be garbage, and this will give the driver a chance 
to close (or otherwise clean up) the objects. Note, however, that there is no guarantee that the 
garbage collector will ever run, so you can't rely on the finalizers being called.
<p>


<br>
<hr> 
<font size=-1>
<a href="jdbc-spec.frame.html">Contents</a>  | <a href="jdbc-spec.frame16.html">Prev</a>  | <a href="jdbc-spec.frame18.html">Next</a>
</font>
<hr>



<address>
<a href="mailto:jdbc@wombat.eng.sun.com">jdbc@wombat.eng.sun.com</a>
or
<a href="mailto:jdbc-odbc@wombat.eng.sun.com">jdbc-odbc@wombat.eng.sun.com</a>
</address>

<a href="../../../relnotes/SMICopyright.html">
<font size=-1><i>Copyright &#169; 1996, 1997 Sun Microsystems, Inc.   All rights reserved.</i></font>
</a>

<!-- HTML generated by Suzette Pelouch on April 10, 1998 -->

</body>
</html>
