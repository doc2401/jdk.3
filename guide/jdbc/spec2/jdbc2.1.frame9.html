<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title></title>
</head>
<body bgcolor=#ffffff>

<table width=100%><tr>
<td><font size=-1>
<a href="jdbc2.1.frame.html">Contents</a>  | <a href="jdbc2.1.frame8.html">Prev</a>  | <a href="jdbc2.1.frame10.html">Next</a>
</font></td><td align=right><i>JDBC<sup><font size=-2>TM</font></sup> Guide: Getting Started</i></td>
</tr></table>
<hr>
<br>
 

<a name="298134"></a>
<h2>	9	 Customizing SQL Types</h2>

<a name="298478"></a>
This chapter describes the support that the JDBC API provides for customizing the 
mapping of SQL structured and distinct types into Java classes. The customization 
mechanism involves minimal extensions to the JDBC API. The new functionality is an 
extension of the existing <code>getObject()</code> and <code>setObject()</code> mechanism.
<p>

<a name="297862"></a>
<h3>9.1 	  &nbsp; &nbsp; The type mapping</h3>
<a name="298577"></a>
An instance of <code>java.util.Map</code> is used to hold a custom mapping between SQL user-
defined types-structured and distinct types-and Java classes. The<code> java.util.Map 
</code>interface is new in the JDK 1.2 and replaces <code>java.util.Dictionary</code>. Such an object 
is termed a <em>type-map</em> object. A type-map object implements a function from SQL 
names of user-defined types to objects of type <code>java.lang.Class</code>. A type-map object 
determines the class from which to construct an object to contain data of a given SQL 
user-defined type. 
<p>
<a name="298573"></a>
Each <code>Connection </code>has an associated type-map object. The type-map object contains 
type-mappings for translating data of SQL user-defined types in operations on that connection.
Methods are provided for getting and setting a connection's type map. For example,

<p>
<a name="298493"></a>

<p>
<blockquote><pre>java.util.Map map = con.getTypeMap();
<code>con.setTypeMap(map);
</code>

</pre></blockquote><a name="298540"></a>
The <code>Connection.getTypeMap()</code> method returns the type-map object associated with 
a connection, while <code>Connection.setTypeMap()</code> can be used to set a new type mapping.

<p>
<a name="298604"></a>
The mapping mechanism is quite flexible. If a connection's type mapping is not explicitly
initialized by the JDBC application, then the default mappings described in Chapter 
<a href="jdbc2.1.frame8.html#297135">8</a> are used by operations on the connection. If a custom mapping is inserted into the 
type-map for SQL type <code>type-name</code>, then all operations on the connection will use this 
custom mapping for values of type <code>type-name</code>. Finally, we note that type-map objects 
may even be provided explicitly when calling certain <code>getXXX() </code>and<code> setXXX()</code> methods
to override the custom or default mapping associated with a <code>Connection</code>.
<p>

<a name="297863"></a>
<h3>9.2 	  &nbsp; &nbsp; Java class conventions</h3>
<a name="298618"></a>
A Java class which appears in a custom type-map must implement a new interface-
<code>java.sql.SQLData</code>. The <code>SQLData</code> interface contains methods that convert instances of 
SQL user-defined types to Java class instances, and vice versa. For example, the method
<code>SQLData.readSQL()</code> reads a stream of data values and builds a Java object, while 
method <code>SQLData.writeSQL()</code> writes a sequence of values from a Java object to a 
stream. We anticipate that these methods will typically be generated by a tool which 
understands the database schema.
<p>
<a name="298799"></a>

<p>
<a name="298800"></a>

<p>
<a name="291142"></a>
This stream-based approach for exchanging data between SQL and the Java programming
language is conceptually similar to Java object Serialization. The data are read 
from and written to an SQL data stream provided by the JDBC driver. The SQL data 
stream may be implemented on various network protocols and data-formats. It may be 
implemented on any logical data-representation in which the leaf SQL data items (of 
which SQL structured types are composed) can be read from (written to) the data 
stream in a "depth-first" traversal of the structured types. That is, the attributes of an 
SQL structured type appear in the stream in the order in which they are declared in that 
type, and each (perhaps structured) attribute value appears fully (its structure recursively
elaborated) in the stream before the next attribute. For data of SQL structured types 
that use inheritance, the attributes must appear in the stream in the order that they are 
inherited. That is, the attributes of a super-type must appear before attributes of a sub-
type. If multiple inheritance is used, then the attributes of super-types should appear in 
the stream in the order in which the super-types are listed in the type declaration. This 
protocol does not require the database server to have any knowledge of the Java programming
language.
<p>

<a name="293642"></a>
<h3>9.3 	  &nbsp; &nbsp; Streams of SQL data</h3>
<a name="299217"></a>
This section describes the stream interfaces, SQLInput and SQLOutput, which support 
customization of the SQL to Java type mapping. 
<p>

<a name="292203"></a>
<h4>	9.3.1	 Retrieving data</h4>
<a name="289426"></a>
When data of SQL structured and distinct types are retrieved from the database, they 
"arrive" in a stream implementing the <code>SQLInput</code> interface. The <code>SQLInput</code> interface contains
methods for reading individual data values sequentially from the stream. The example
below illustrates how a <code>SQLInput</code> stream can be used to provide values for the 
fields of an <code>SQLData</code> object. The <code>SQLData</code> object-the <code>this</code> object in the example-
contains three persistent fields: a <code>String s</code>, a <code>Blob blob</code>, and an <code>Employee emp</code>.
<p>
<a name="298685"></a>

<p>
<blockquote><pre>this.str = sqlin.readString();
this.blob = sqlin.readBlob();
this.emp = (Employee)sqlin.readObject();


</pre></blockquote><a name="289633"></a>
The <code>SQLInput.readString()</code> method reads a <code>String</code> value from the stream. The 
<code>SQLInput.readBlob() method </code>can be used to retrieve a <code>Blob</code> value from the stream. 
By default, the <code>Blob</code> interface is implemented using an SQL locator, so calling <code>readBlob()
</code> doesn't materialize the blob contents on the client. The <code>SQLInput.readObject()
</code> method can be used to return an object reference from the stream. In the 
example, the <code>Object</code> returned is narrowed to an <code>Employee</code>.
<p>
<a name="298692"></a>
There are a number of additional <code>readXXX()</code> methods defined on the <code>SQLInput</code> interface
for reading each of the types. The <code>SQLInput.wasNull()</code> method can be called to 
check if the value returned by a <code>readXXX()</code> method was null.
<p>

<a name="289634"></a>
<h4>	9.3.2	 Storing data</h4>
<a name="295287"></a>
When an <code>SQLData</code> object is passed to a driver as an input parameter via a <code>setXXX()</code> 
method, the JDBC driver calls the object's <code>SQLData.writeSql()</code> method to obtain a 
stream representation of the contents of the object. Method <code>writeSQL() </code>writes data 
from the object to an <code>SQLOutput</code> stream as the representation of an SQL user-defined 
type.  Method <code>writeSQL() </code>will typically have been generated by some tool from an 
SQL type definition. The example below illustrates use of the <code>SQLOutput</code> stream object.

<p>
<a name="289851"></a>

<p>
<blockquote><pre>sqlout.writeString(this.str);
sqlout.writeBlob(this.blob);
sqlout.writeObject(this.emp);

</pre></blockquote><a name="298732"></a>
The example shows how the contents of an <code>SQLData</code> object can be written to an 
<code>SQLOutput</code> stream. The <code>SQLData</code> object-the <code>this</code> object in the example-contains 
three persistent fields: a <code>String s</code>, a <code>Blob blob</code>, and an <code>Employee emp</code>. Each field is 
written in turn to the <code>SQLOutput</code> stream, <code>sqlout</code>. The <code>SQLOutput</code> interface contains additional
methods for writing each of the types defined in the JDBC API.
<p>

<a name="298943"></a>
<h3>9.4 	  &nbsp; &nbsp; Examples</h3>

<a name="298944"></a>
<h4>	9.4.1	 Example of SQL structured type</h4>
<a name="298945"></a>
The following SQL example defines structured types PERSON, FULLNAME, and 
RESIDENCE. It defines tables with rows of types PERSON and RESIDENCE, and inserts
a row into each, so that one row references another. Finally, it queries the table.
<p>
<a name="298946"></a>

<p>
<blockquote><pre>CREATE TYPE RESIDENCE 
(
	DOOR NUMERIC(6),
	STREET VARCHAR(100), 
	CITY VARCHAR(50),
	OCCUPANT REF(PERSON)
);

CREATE TYPE FULLNAME
(
	FIRST VARCHAR(50),
	LAST VARCHAR(50)
);

CREATE TYPE PERSON 
(
	NAME FULLNAME,
	HEIGHT NUMERIC,
	WEIGHT NUMERIC,
	HOME REF(RESIDENCE)
);


CREATE TABLE HOMES OF RESIDENCE (OID REF(RESIDENCE) 
	VALUES ARE SYSTEM GENERATED);

CREATE TABLE PEOPLE OF PERSON (OID REF(PERSON) 
	VALUES ARE SYSTEM GENERATED);

INSERT INTO PEOPLE (SURNAME, HEIGHT, WEIGHT) VALUES 
(
	FULLNAME('DAFFY', 'DUCK'), 
	4, 
	58
);

INSERT INTO HOMES (DOOR, STREET, CITY, OCCUPANT) VALUES 
(
	1234, 
	'CARTOON LANE', 
	'LOS ANGELES',
	(SELECT OID FROM PEOPLE P WHERE P.NAME.FIRST = 'DAFFY')
);

UPDATE PEOPLE SET HOME = (SELECT OID FROM HOMES H WHERE 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H.OCCUPANT-&gt;NAME.FIRST = 'DAFFY') WHERE 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FULLNAME.FIRST = 'DAFFY'
</pre></blockquote><a name="298992"></a>

<p>
<a name="298993"></a>
The example above constructs three structured type instances, one each of types PERSON,
FULLNAME, and RESIDENCE. A FULLNAME attribute is embedded in a 
PERSON. The PERSON and RESIDENCE instances are stored as rows of tables, and 
reference each other via Ref attributes.
<p>
<a name="298994"></a>
The Java classes below represent the SQL structured types given above. We expect that 
such classes will typically be generated by a tool that reads the definitions of those 
structured types from the catalog tables, and, subject to customizations that a user of the 
tool may provide for name-mappings and type-mappings of primitive fields, will generate
Java classes like those shown below. 
<p>
<a name="301075"></a>
Note: The JDBC API does not provide a standard API for accessing the metadata needed
by a mapping tool. Providing this type of metadata introduces many subtle dependencies
on the SQL99 type model, so it has been left out for now.
<p>
<a name="301071"></a>
In each class below, method <code>SQLData.readSQL()</code> reads the attributes in the order that 
they appear in the definition of the corresponding structured types in the database (i.e., 
in "row order, depth-first" order, where the complete structure of each attribute is read, 
recursively, before the next attribute is read).  Similarly, <code>SQLData.writeSQL()</code> writes 
the data to the stream in that order.
<p>
<a name="301069"></a>

<p>
<blockquote><pre>public class Residence implements SQLData {
    public int door;
    public String street;
    public String city;
    public Ref occupant;

    private String sql_type;
&nbsp;&nbsp;&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

    public void readSQL (SQLInput stream, String type) 
	throws SQLException {
      sql_type = type;
      door = stream.readInt();
      street = stream.readString();
      city = stream.readString();
      occupant = stream.readRef();
&nbsp;&nbsp;&nbsp;&nbsp;}

    public void writeSQL (SQLOutput stream) throws SQLException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.writeInt(door);
      stream.writeString(street);
      stream.writeString(city);
      stream.writeRef(occupant);
    }
}	 

public class Fullname implements SQLData {
    public String first;
    public String last;

    private String sql_type;
&nbsp;&nbsp;&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

    public void readSQL (SQLInput stream, String type)
	throws SQLException {
      sql_type = type;
      first = stream.readString();
      last = stream.readString();
&nbsp;&nbsp;&nbsp;&nbsp;}

    public void writeSQL (SQLOutput stream) throws SQLException {
      stream.writeString(first);
      stream.writeString(last);
    }
}

public class Person implements SQLData {
    Fullname name;
    float height;
    float weight;
    Ref home;

    private String sql_type;
&nbsp;&nbsp;&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

    public void readSQL (SQLInput stream, String type) 
	throws SQLException {
      sql_type = type;
      name = (Fullname)stream.readObject();
      height = stream.readFloat();
      weight = stream.readFloat();
      home = stream.readRef();
    }

    public void writeSQL (SQLOutput stream) 
    	throws SQLException {
      stream.writeObject(name);
      stream.writeFloat(height);
      stream.writeFloat(weight);
      stream.writeRef(home);
    }
}
</pre></blockquote><a name="299077"></a>

<p>
<a name="299078"></a>
The following method uses those classes to materialize data from the tables HOMES 
and PEOPLE that were defined earlier:
<p>
<a name="299079"></a>

<p>
<blockquote><pre>import java.sql.*;
.
.
.

public void demo (Connection con) throws SQLException {

&nbsp;&nbsp;// setup mappings for the connection
&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;java.util.Map map = con.getTypeMap();
&nbsp;&nbsp;&nbsp;&nbsp;map.put("S.RESIDENCE", Class.forName("Residence"));
&nbsp;&nbsp;&nbsp;&nbsp;map.put("S.FULLNAME", Class.forName("Fullname"));
&nbsp;&nbsp;&nbsp;&nbsp;map.put("S.PERSON", Class.forName("Person"));
&nbsp;&nbsp;}
&nbsp;&nbsp;catch (ClassNotFoundException ex) {}

&nbsp;&nbsp;PreparedStatement pstmt;
&nbsp;&nbsp;ResultSet rs;

&nbsp;&nbsp;pstmt = con.prepareStatement("SELECT OCCUPANT FROM HOMES");
&nbsp;&nbsp;rs = pstmt.executeQuery();
&nbsp;&nbsp;rs.next();
&nbsp;&nbsp;Ref ref = rs.getRef(1); 

&nbsp;&nbsp;pstmt = con.prepareStatement(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"SELECT FULLNAME FROM PEOPLE WHERE OID = ?");
&nbsp;&nbsp;pstmt.setRef(1, ref);
&nbsp;&nbsp;rs = pstmt.executeQuery();
&nbsp;&nbsp;rs.next();
&nbsp;&nbsp;Fullname who = (Fullname)rs.getObject(1);

&nbsp;&nbsp;// prints "Daffy Duck"
&nbsp;&nbsp;System.out.println(who.first + " " + who.last); 
}
</pre></blockquote>
<a name="299109"></a>
<h4>	9.4.2	 Mirroring SQL inheritance in the Java programming language</h4>
<a name="299110"></a>
SQL structured types may be defined to form an inheritance hierarchy.  For example, 
consider SQL type STUDENT that inherits from PERSON:
<p>
<a name="299111"></a>

<p>
<blockquote><pre>CREATE TYPE PERSON AS OBJECT (NAME VARCHAR(20), BIRTH DATE);

CREATE TYPE STUDENT AS OBJECT EXTENDS PERSON (GPA NUMERIC(4,2));
</pre></blockquote><a name="299115"></a>

<p>
<a name="299116"></a>
The following Java classes can represent data of those SQL types. Class <code>Student</code> extends
<code>Person</code>, mirroring the SQL type hierarchy. Methods <code>SQLData.readSQL()</code> and 
<code>SQLData.writeSQL() </code>of the subclass cascades each call to the corresponding method 
in its super-class, in order to read or write the super-class attributes before reading or 
writing the subclass attributes.
<p>
<a name="299117"></a>

<p>
<blockquote><pre>   import java.sql.*;
   ...
   public class Person implements SQLData {
     public String name;
     public Date birth;

     private String sql_type;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

     public void readSQL (SQLInput data, String type) 
	throws SQLException { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql_type = type;
       name = data.readString();
       birth = data.readDate();
     }

     public void writeSQL (SQLOutput data)
     	throws SQLException { 
       data.writeString(name);
       data.writeDate(birth);
     }
   }

   public class Student extends Person {
     public float GPA;

     private String sql_type;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

     public void readSQL (SQLInput data, String type) 
	throws SQLException { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql_type = type;
       super.readSQL(data, type);
       GPA = data.readFloat();
     }

     public void writeSQL (SQLOutput data)
     throws SQLException {
       super.writeSQL(data);
       data.writeFloat(GPA);
     }
   }
</pre></blockquote><a name="299160"></a>

<p>
<a name="301455"></a>
The Java class hierarchy need not mirror the SQL inheritance hierarchy. For example, 
class <code>Student</code> above could have been declared without a super-class. In this case, <code>Student
</code> could contain fields to hold the inherited attributes of the SQL type STUDENT as 
well as the attributes declared by STUDENT itself..
<p>

<a name="299161"></a>
<h4>	9.4.3	 Example mapping of SQL distinct type</h4>
<a name="299162"></a>
An SQL distinct type, MONEY, and a Java class Money that represents it:
<p>
<blockquote><pre>

-- SQL definition
CREATE TYPE MONEY AS NUMERIC(10,2);  

// definition
public class Money implements SQLData { 

&nbsp;&nbsp;public java.math.BigDecimal value;

&nbsp;&nbsp;private String sql_type;
&nbsp;&nbsp;public String getSQLTypeName() { return sql_type; }

&nbsp;&nbsp;public void readSQL (SQLInput stream, String type) 
	throws SQLException {
&nbsp;&nbsp;&nbsp;&nbsp;sql_type = type;
&nbsp;&nbsp;&nbsp;&nbsp;value = stream.readBigDecimal();
&nbsp;&nbsp;}

&nbsp;&nbsp;public void writeSQL (SQLOutput stream) throws SQLException {
&nbsp;&nbsp;&nbsp;&nbsp;stream.writeBigDecimal(value);
&nbsp;&nbsp;}
}
</pre></blockquote><a name="298941"></a>

<p>

<a name="298933"></a>
<h3>9.5 	  &nbsp; &nbsp; Generality of the approach</h3>
<a name="298934"></a>
Users have great flexibility to customize the Java classes that represent SQL structured 
and distinct types. They control the mappings of built-in SQL attribute types to Java 
field types. They control the mappings of SQL names (of types and attributes) to Java 
names (of classes and fields). Users may add (to Java classes that represent SQL types) 
fields and methods that implement domain-specific functionality. Users can generate 
beans as the classes that represent SQL types.
<p>
<a name="298935"></a>
A user can even map a single SQL type to different Java classes, depending on arbitrary 
conditions. To do that, the user must customize the implementation of <code>SQLData.readSQL()
</code> to construct and return objects of different classes under different conditions.
<p>
<a name="298936"></a>
Similarly, the user can map a single SQL value to a graph of Java objects. Again, that 
is accomplished by customizing the implementation of <code>SQLData.readSQL()</code> to construct
multiple objects and distribute the SQL attributes into fields of those objects. 
<p>
<a name="298937"></a>
A customization of the <code>SQLData.readSQL()</code> method could populate the type-map object
incrementally. And so on. We believe that these kinds of flexibility will allow users 
to map SQL types appropriately for different kinds of applications.
<p>

<a name="298924"></a>
<h3>9.6 	  &nbsp; &nbsp; NULL data</h3>
<a name="298916"></a>
An application uses the existing <code>getObject()</code> and <code>setObject()</code> mechanism to retrieve 
and store <code>SQLData</code> values. We note that when the second parameter, <code>x</code>, of method<code> PreparedStatement.setObject()
</code>has the value <code>null</code>, then the driver executes the SQL 
statement as if the SQL literal NULL had appeared in place of that parameter of the 
statement:
<p>
<a name="290184"></a>

<p>
<blockquote><pre>  void setObject (int i, Object x) throws SQLException;
</pre></blockquote><a name="290187"></a>

<p>
<a name="290189"></a>
When parameter <code>x</code> is null, there is no enforcement that the corresponding argument expression
is of a Java type that could successfully be passed to that SQL statement if its 
value were non-null. The Java programming language null carries no type information. 
For example, a null Java programming language variable of class <code>AntiMatter</code> could be 
passed as an argument to an SQL statement that requires a value of SQL type <code>MATTER</code>, 
and no error would result, even though the relevant type-map object did not permit the 
translation of <code>MATTER</code> to <code>AntiMatter</code>.
<p>

<a name="290529"></a>
<h3>9.7 	  &nbsp; &nbsp; Summary</h3>
<a name="290533"></a>
Chapters <a href="jdbc2.1.frame8.html#297135">8</a> and <a href="jdbc2.1.frame9.html#298134">9</a> presented extensions to support new categories of SQL types. The extensions
have these properties:
<p>

<ul><a name="290536"></a>
<li>All of the new SQL types are handled with uniform and extensible interfaces, 
which may be staged into the JDBC API piecemeal.
<br><br>
<a name="290541"></a>
<li>Minimal mechanism is added to the API. An implementation does little more 
than transfer control to methods <code>SQLData.readSQL()</code> and 
<code>SQLData.writeSQL() </code>of classes that have been generated to represent the SQL 
types.
<br><br>
<a name="299282"></a>
<li>The extensions are based on existing interfaces <code>java.io.Serializable</code>, 
<code>java.io.DataInput</code>, <code>java.io.DataOutput</code>, <code>java.sql.ResultSet</code>, and 
<code>java.sql.PreparedStatement 
</code><br><br>
<a name="292550"></a>
<li>Great flexibility is given to writers of database tools to add value by 
customizing the Java classes that represent SQL data.
<br><br>
</ul><a name="290553"></a>

<p>


<br>
<hr> 
<font size=-1>
<a href="jdbc2.1.frame.html">Contents</a>  | <a href="jdbc2.1.frame8.html">Prev</a>  | <a href="jdbc2.1.frame10.html">Next</a>
</font>
<hr>



<address>
<a href="mailto:jdbc@eng.sun.com">jdbc@eng.sun.com</a>
or
<a href="mailto:jdbc-business@eng.sun.com">jdbc-business@eng.sun.com</a>
</address>

<i><a href="../../../relnotes/SMICopyright.html">
Copyright</a> &#169; 1996-1999 Sun Microsystems, Inc.   All rights reserved.</i>


<!-- HTML generated by Suzette Pelouch on December 01, 1999 -->

</body>
</html>
