<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Permissions in the Java(TM) 2 SDK</title>
  </head>

  <body bgcolor="white">

<center>

      <h1>Permissions in the Java<sup><font size=-2>TM</font></sup> 2 SDK</h1>

</center>

<br><br>

<p>A permission represents access to a system resource.
In order for a resource access to be allowed for an applet
(or an application running with a security manager),
the corresponding permission must be explicitly granted to
the code attempting the access.

<p>A permission typically has a name (often referred to as a
"target name") and, in some cases, a comma-separated list of
one or more actions. For example, the following code
creates a FilePermission object representing read access to
the file named <code>abc</code> in the <code>/tmp</code> directory:

<pre>
    perm = new java.io.FilePermission("/tmp/abc", "read");
</pre>

In this, the target name is "/tmp/abc" and the action string
is "read".

<p><b>Important:</b> The above statement creates a permission object.
A permission object represents, but does not grant
access to, a system resource.
Permission objects are constructed and assigned ("granted") to code
based on the policy in effect.
When a permission object is assigned to some code, that
code is granted the permission to access the system resource
specified in the permission object, in the specified manner.
A permission object may also be constructed by the current
security manager
when making access decisions. In this case, the (target) permission
object is created based on the requested access, and checked against the
permission objects granted to and held by the code making the request.

<p>The policy for a Java application environment 
is represented by a Policy object. 
In the default Policy implementation, the policy 
can be specified within one 
or more policy configuration files. 
The policy file(s) specify what 
permissions are allowed for code from specified code sources.
A sample policy file entry granting code from
the <code>/home/sysadmin</code> directory 
read access to the file <code>/tmp/abc</code> is

<pre>
  grant codeBase "file:/home/sysadmin/" {
    permission java.io.FilePermission "/tmp/abc", "read";
  };
</pre>

<p>For information about policy file locations and
granting permissions in policy files, see
<a href="PolicyFiles.html">Default Policy Implementation and Policy File Syntax</a>. 
For information about using the <b>Policy Tool</b> to specify the
permissions, see the Policy Tool documentation
(<a href="../../tooldocs/solaris/policytool.html">for Solaris</a>) 
(<a href="../../tooldocs/win32/policytool.html">for Windows</a>).
Using the <b>Policy Tool </b> saves typing and eliminates the need
for you to know the required syntax of policy files.

<p>Technically, whenever a resource access is attempted, <i>all</i> code 
traversed by the execution thread up to that point must have permission 
for that resource access, unless some code on the thread has been marked 
as "privileged." See
<a href="doprivileged.html">API for Privileged Blocks</a> for more
information about "privileged" code.

<p>This document contains tables that describe the built-in
Java 2 SDK permission types and discuss the risks of granting each 
permission. It also contains tables showing the methods that
require permissions to be in effect in order to be successful,
and for each lists the required permission.

<p>The tables are the following:

<dl>

<dt><dd><a href="#PermRisks">
<b>Permission Descriptions and Risks</b>
</a><dl>

<dt><dd><a href="#AllPermission">
<b>AllPermission</b>
<dt><dd><a href="#AudioPermission">
<b>AudioPermission</b>
</a><dt><dd><a href="#AWTPermission">
<b>AWTPermission</b>
</a><dt><dd><a href="#FilePermission">
<b>FilePermission</b>
</a><dt><dd><a href="#NetPermission">
<b>NetPermission</b>
</a><dt><dd><a href="#PropertyPermission">
<b>PropertyPermission</b>
</a><dt><dd><a href="#ReflectPermission">
<b>ReflectPermission</b>
</a><dt><dd><a href="#RuntimePermission">
<b>RuntimePermission</b>
</a><dt><dd><a href="#SecurityPermission">
<b>SecurityPermission</b>
</a><dt><dd><a href="#SerializablePermission">
<b>SerializablePermission</b>
</a><dt><dd><a href="#SocketPermission">
<b>SocketPermission</b>
</a><dt><dd><a href="#SQLPermission">
<b>SQLPermission</b>
</a></dl>
<br>


<dt><dd><a href="#PermsAndMethods">
<b>Methods and the Permissions They Require</b>
</a>

<br>
<br>

<dt><dd><a href="#SecMgrChecks">
<b>java.lang.SecurityManager Method Permission Checks</b>
</a></dl>
<br>

<p>For more information about permissions, including the superclasses
<code>java.security.Permission</code> and 
<code>java.security.BasicPermission</code>, and examples
of creating permission objects and granting permissions, see the 
<a href="spec/security-spec.doc.html">
<b>Security Architecture Specification</b></a>.


<p>
<hr>


<h1><a name="PermRisks">Permission Descriptions and Risks</a></h1>

<blockquote>


<p>The following tables describe the built-in
Java 2 SDK permission types and discuss the risks of granting each 
permission.


<H2><a name="AllPermission">AllPermission</a></H2>

<blockquote>

The <code>java.security.AllPermission</code> is a permission that implies all 
other permissions.
<p>
<b>Note:</b> Granting <code>AllPermission</code> should be done 
with extreme care,
as it implies all other permissions. Thus, it grants code the ability 
to run with security
disabled.  Extreme caution should be taken before granting such
a permission to code.  This permission should be used only during testing,
or in extremely rare cases where an application or applet is
completely trusted and adding the necessary permissions to the policy 
is prohibitively cumbersome.

</blockquote>

<H2><a name="AudioPermission">AudioPermission</a></H2>
<blockquote>
The <code>AudioPermission</code> class represents access rights to the audio 
 system resources.  An <code>AudioPermission</code> contains a target name 
 but no actions list; you either have the named permission or you don't. 
 <p>
 The target name is the name of the audio permission (see the table below). 
 The names follow the hierarchical property-naming convention. Also, an asterisk
 
 can be used to represent all the audio permissions. 
 <p>
 The following table lists the possible <code>AudioPermission</code> target name
s.  
 For each name, the table provides a description of exactly what that permission
 allows, as well as a discussion of the risks of granting code the permission. 
 <p>

 <table border=1 cellpadding=5>
 <tr>
 <th>Permission Target Name</th>
 <th>What the Permission Allows</th>
 <th>Risks of Allowing this Permission</th>
 </tr>

 <tr>
 <td>play</td>
 <td>Audio playback through the audio device or devices on the system.
 Allows the application to obtain and manipulate lines and mixers for 
 audio playback (rendering).</td> 
 <td>In some cases use of this permission may affect other 
 applications because the audio from one line may be mixed with other audio
 being played on the system, or because manipulation of a mixer affects the
 audio for all lines using that mixer.</td>
</tr>

 <tr>
 <td>record</td>
 <td>Audio recording through the audio device or devices on the system.
 Allows the application to obtain and manipulate lines and mixers for 
 audio recording (capture).</td> 
 <td>In some cases use of this permission may affect other 
 applications because manipulation of a mixer affects the audio for all lines 
 using that mixer.
 This permission can enable an applet or application to eavesdrop on a user.
</td>
</tr>
</table>
</blockquote>


<H2><a name="AWTPermission">AWTPermission</a></H2>

<blockquote>

A <code>java.awt.AWTPermission</code> is for AWT permissions.

<p>The following table lists all the possible <code>AWTPermission</code>
target names,
and for each provides a description of what the permission allows
and a discussion of the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.awt.AWTPermission<br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>accessClipboard</td>
  <td>Posting and retrieval of information to and from the AWT clipboard</td>
  <td>This would allow malfeasant code to share
potentially sensitive or confidential information.</td>
</tr>

<tr>
  <td>accessEventQueue</td>
  <td>Access to the AWT event queue</td>
  <td>After retrieving the AWT event queue,
malicious code may peek at and even remove existing events
from the system, as well as post bogus events which may purposefully
cause the application or applet to misbehave in an insecure manner.</td>
</tr>

<tr>
  <td>createRobot</td>
  <td>Create java.awt.Robot objects</td>
  <td>The java.awt.Robot object allows code to generate native-level
      mouse and keyboard events as well as read the screen. It could
      allow malicious code to control the system, run other programs,
      read the display, and deny mouse and keyboard access to the user.</td>
</tr>

<tr>
  <td>listenToAllAWTEvents</td>
  <td>Listen to all AWT events, system-wide</td>
  <td>After adding an AWT event listener,
malicious code may scan all AWT events dispatched in the system,
allowing it to read all user input (such as passwords).  Each
AWT event listener is called from within the context of that
event queue's EventDispatchThread, so if the accessEventQueue
permission is also enabled, malicious code could modify the
contents of AWT event queues system-wide, causing the application
or applet to misbehave in an insecure manner.</td>
</tr>

<tr>
  <td>readDisplayPixels</td>
  <td>Readback of pixels from the display screen</td>
  <td>Interfaces such as the java.awt.Composite interface which
allow arbitrary code to examine pixels on the display enable
malicious code to snoop on the activities of the user.</td>
</tr>

<tr>
  <td>showWindowWithoutWarningBanner</td>
  <td>Display of a window without also displaying a banner warning 
that the window was created by an applet</td>
  <td>Without this warning,
an applet may pop up windows without the user knowing that they
belong to an applet.  Since users may make security-sensitive
decisions based on whether or not the window belongs to an applet
(entering a username and password into a dialog box, for example),
disabling this warning banner may allow applets to trick the user
into entering such information.</td>
</tr>

</table>

</blockquote>




<H2><a name="FilePermission">FilePermission</a></H2>

<blockquote>

A <code>java.io.FilePermission</code> represents access to a file or directory. A <code>FilePermission</code> consists
of a pathname and a set of actions valid for that pathname.
<P>
Pathname is the pathname of the file or directory granted the specified
actions. A pathname that ends in "/*" (where "/" is
the file separator character, <code>File.separatorChar</code>) indicates
a directory and all the files contained in that directory. A pathname
that ends with "/-" indicates a directory and (recursively) all files
and subdirectories contained in that directory. A pathname consisting of
the special token "&lt;&lt;ALL FILES&gt;&gt;" matches <bold>any</bold> file.
<P>
A pathname consisting of a single "*" indicates all the files
in the current directory, while a pathname consisting of a single "-" 
indicates all the files in the current directory and
(recursively) all files and subdirectories contained in the current 
directory.
<P>
The actions to be granted are passed to the constructor in a string containing 
a list of zero or more comma-separated keywords. The possible keywords are
"read", "write", "execute", and "delete". Their meaning is defined as follows:
<P>
<DL> 
   <DT> read <DD> Permission to read.
   <DT> write <DD> Permission to write (which includes permission to create).
   <DT> execute 
   <DD> Permission to execute. Allows <code>Runtime.exec</code> to
        be called. Corresponds to <code>SecurityManager.checkExec</code>.
   <DT> delete
   <DD> Permission to delete. Allows <code>File.delete</code> to
        be called. Corresponds to <code>SecurityManager.checkDelete</code>.
</DL>
<P>
The actions string is converted to lowercase before processing.
<P>
Be careful when granting <code>FilePermission</code>s. 
Think about the implications 
of granting read and especially write access to various files and 
directories. The "&lt;&lt;ALL FILES>>" permission with write action is 
especially dangerous. This grants permission to write to the entire 
file system. One thing this effectively allows is replacement of the 
system binary, including the JVM runtime environment.

<p>Please note: code can always read a file from the same
directory it's in (or a subdirectory of that directory); it does not
need explicit permission to do so.

</blockquote>


<H2><a name="NetPermission">NetPermission</a></H2>

<blockquote>

A <code>java.net.NetPermission</code> is for various network permissions. 
A <code>NetPermission</code> contains a name but
no actions list; you either have the named permission 
or you don't.
<P>
The following table lists all the possible NetPermission target names,
and for each provides a description of what the permission allows
and a discussion of the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.net.NetPermission<br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>setDefaultAuthenticator</td>
  <td>The ability to set the
way authentication information is retrieved when
a proxy or HTTP server asks for authentication</td>
  <td>Malicious
code can set an authenticator that monitors and steals user
authentication input as it retrieves the input from the user.</td>
</tr>

<tr>
  <td>requestPasswordAuthentication</td>
  <td>The ability
to ask the authenticator registered with the system for
a password</td>
  <td>Malicious code may steal this password.</td>
</tr>

<tr>
  <td>specifyStreamHandler</td>
  <td>The ability
to specify a stream handler when constructing a URL</td>
  <td>Malicious code may create a URL with resources that it would
normally not have access to (like file:/foo/fum/), specifying a
stream handler that gets the actual bytes from someplace it does 
have access to. Thus it might be able to trick the system into
creating a ProtectionDomain/CodeSource for a class even though
that class really didn't come from that location.</td>
</tr>

</table>

</blockquote>


<H2><a name="PropertyPermission">PropertyPermission</a></H2>

<blockquote>

A <code>java.util.PropertyPermission</code> is for property permissions. 

<P>
The name is the name of the property ("java.home",
"os.name", etc). The naming
convention follows the  hierarchical property naming convention.
Also, an asterisk 
may appear at the end of the name, following a ".", or by itself, to 
signify a wildcard match. For example: "java.*" or "*" is valid, 
"*java" or "a*b" is not valid.
<P>
<P>
The actions to be granted are passed to the constructor in a string containing 
a list of zero or more comma-separated keywords. The possible keywords are
"read" and "write". Their meaning is defined as follows:
<P>
<DL> 
   <DT> read 
   <DD> Permission to read. Allows <code>System.getProperty</code> to
        be called.
   <DT> write
   <DD> Permission to write. Allows <code>System.setProperty</code> to
        be called. 
</DL>
<P>
The actions string is converted to lowercase before processing.
<P>
Care should be taken before granting code permission to access
certain system properties.  For example, granting permission to
access the "java.home" system property gives potentially malevolent
code sensitive information about the system environment (the location 
of the runtime environment's directory).  Also, granting permission to access
the "user.name" and "user.home" system properties gives potentially
malevolent code sensitive information about the user environment
(the user's account name and home directory).

</blockquote>


<H2><a name="ReflectPermission">ReflectPermission</a></H2>

<blockquote>

A <code>java.lang.reflect.ReflectPermission</code> is for reflective 
operations.  A
ReflectPermission is a <em>named permission</em> and has no
actions.  The only name currently defined is <tt>suppressAccessChecks</tt>,
which allows suppressing the standard language access checks
-- for public, default (package) access, protected, and private
members -- performed by reflected objects at their point of use.
<P>
The following table 
provides a summary description of what the permission allows,
and discusses the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.lang.reflect.ReflectPermission <br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>suppressAccessChecks</td>
  <td>The ability to access
fields and invoke methods in a class. Note that this includes
not only public, but protected and private fields and methods as well.</td>
  <td>This is dangerous in that information (possibly confidential) and
methods normally unavailable would be accessible to malicious code.</td>
</tr>

</table>

</blockquote>



<H2><a name="RuntimePermission">RuntimePermission</a></H2>

<blockquote>

A <code>java.lang.RuntimePermission</code> is for runtime permissions. 
A <code>RuntimePermission</code> 
contains a name (also referred to as a "target name") but
no actions list; you either have the named permission 
or you don't.

<P>
The target name is the name of the runtime permission (see below). The naming
convention follows the  hierarchical property naming convention.
Also, an asterisk 
may appear at the end of the name, following a ".", or by itself, to 
signify a wildcard match. For example: "loadLibrary.*" or "*" is valid, 
"*loadLibrary" or "a*b" is not valid.
<P>
The following table lists all the possible <code>RuntimePermission</code>
target names,
and for each provides a description of what the permission allows
and a discussion of the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.lang.RuntimePermission <br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>createClassLoader</td>
  <td>Creation of a class loader</td>
  <td>This is an extremely dangerous permission to grant.
Malicious applications that can instantiate their own class
loaders could then load their own rogue classes into the system.
These newly loaded classes could be placed into any protection
domain by the class loader, thereby automatically granting the
classes the permissions for that domain.</td>
</tr>

<tr>
  <td>getClassLoader</td>
  <td>Retrieval of a class loader (e.g., the class loader for the calling class)</td>
  <td>This would grant an attacker permission to get the
class loader for a particular class. This is dangerous because
having access to a class's class loader allows the attacker to
load other classes available to that class loader. The attacker
would typically otherwise not have access to those classes.</td>
</tr>

<tr>
  <td>setContextClassLoader</td>
  <td>Setting of the context class loader used by a thread</td>
  <td>The context class loader is used by system code and extensions 
when they need to lookup resources that might not exist in the system 
class loader. Granting setContextClassLoader permission would allow 
code to change which context class loader is used
for a particular thread, including system threads.</td>
</tr>

<tr>
  <td>setSecurityManager</td>
  <td>Setting of the security manager (possibly replacing an existing one)
</td>
  <td>The security manager is a class that allows 
applications to implement a security policy. Granting the setSecurityManager
permission would allow code to change which security manager is used by
installing a different, possibly less restrictive security manager,
thereby bypassing checks that would have been enforced by the original
security manager.</td>
</tr>

<tr>
  <td>createSecurityManager</td>
  <td>Creation of a new security manager</td>
  <td>This gives code access to protected, sensitive methods that may
disclose information about other classes or the execution stack.</td>
</tr>

<tr>
  <td>exitVM</td>
  <td>Halting of the Java Virtual Machine</td>
  <td>This allows an attacker to mount a denial-of-service attack
by automatically forcing the virtual machine to halt.</td>
</tr>

<tr>
  <td>shutdownHooks</td>
  <td>Registration and cancellation of virtual-machine shutdown hooks</td>
  <td>This allows an attacker to register a malicious shutdown hook that
      interferes with the clean shutdown of the virtual machine.</td>
</tr>

<tr>
  <td>setFactory</td>
  <td>Setting of the socket factory used by ServerSocket or Socket,
or of the stream handler factory used by URL</td>
  <td>This allows code to set the actual implementation
for the socket, server socket, stream handler, or RMI socket factory.
An attacker
may set a faulty implementation which mangles the data stream.</td>
</tr>

<tr>
  <td>setIO</td>
  <td>Setting of System.out, System.in, and System.err</td>
  <td>This allows changing the value of the standard system streams.
An attacker may change System.in to monitor and
steal user input, or may set System.err to a "null" OutputSteam,
which would hide any error messages sent to System.err. </td>
</tr>

<tr>
  <td>modifyThread</td>
  <td><odification of threads, e.g., via calls to Thread <code>stop</code>,
<code>suspend</code>, <code>resume</code>, <code>setPriority</code>,
and <code>setName</code> methods</td>
  <td>This allows an attacker to start or suspend any thread
in the system.</td>
</tr>

<tr>
  <td>stopThread</td>
  <td>Stopping of threads via calls to the Thread <code>stop</code>
method</td>
  <td>This allows code to stop any thread in the system
provided that it is already granted permission to access that thread.
This poses as a threat, because that code may corrupt the system by
killing existing threads.</td>
</tr>

<tr>
  <td>modifyThreadGroup</td>
  <td>Modification of thread groups, e.g., via calls to ThreadGroup 
<code>destroy</code>, <code>resume</code>, <code>setDaemon</code>,
<code>setMaxPriority</code>, <code>stop</code>, and <code>suspend</code>
methods</td>
  <td>This allows an attacker to create thread groups and
set their run priority.</td>
</tr>

<tr>
  <td>getProtectionDomain</td>
  <td>Retrieval of the ProtectionDomain for a class</td>
  <td>This allows code to obtain policy information
for a particular code source. While obtaining policy information
does not compromise the security of the system, it does give
attackers additional information, such as local file names for
example, to better aim an attack.</td>
</tr>

<tr>
  <td>readFileDescriptor</td>
  <td>Reading of file descriptors</td>
  <td>This would allow code to read the particular file associated
with the file descriptor read. This is dangerous if the file contains
confidential data.</td>
</tr>

<tr>
  <td>writeFileDescriptor</td>
  <td>Writing to file descriptors</td>
  <td>This allows code to write to a particular file associated
with the descriptor. This is dangerous because it may allow malicous
code to plant viruses or at the very least, fill up your entire disk.</td>
</tr>

<tr>
  <td>loadLibrary.{library name}</td>
  <td>Dynamic linking of the specified library</td>
  <td>It is dangerous to allow an applet permission to load native code
libraries, because the Java security architecture is not designed to and
does not prevent malicious behavior at the level of native code.</td>
</tr>

<tr>
  <td>accessClassInPackage.{package name}</td>
  <td>Access to the specified package via a class loader's 
<code>loadClass</code> method when that class loader calls
the SecurityManager <code>checkPackageAcesss</code> method</td>
  <td>This gives code access to classes in packages
to which it normally does not have access. Malicious code
may use these classes to help in its attempt to compromise
security in the system.</td>
</tr>

<tr>
  <td>defineClassInPackage.{package name}</td>
  <td>Definition of classes in the specified package, via a class
loader's <code>defineClass</code> method when that class loader calls
the SecurityManager <code>checkPackageDefinition</code> method.</td>
  <td>This grants code permission to define a class
in a particular package. This is dangerous because malicious
code with this permission may define rogue classes in
trusted packages like <code>java.security</code> or <code>java.lang</code>,
for example.</td>
</tr>

<tr>
  <td>accessDeclaredMembers</td>
  <td>Access to the declared members of a class</td>
  <td>This grants code permission to query a class for its public,
protected, default (package) access, and private fields and/or
methods. Although the code would have
access to the private and protected field and method names, it would not
have access to the private/protected field data and would not be able
to invoke any private methods. Nevertheless, malicious code
may use this information to better aim an attack.
Additionally, it may invoke any public methods and/or access public fields
in the class.  This could be dangerous if
the code would normally not be able to invoke those methods and/or
access the fields  because
it can't cast the object to the class/interface with those methods
and fields.
</td>
</tr>
<tr>
  <td>queuePrintJob</td>
  <td>Initiation of a print job request</td>
  <td>This could print sensitive information to a printer,
or simply waste paper.</td>
</tr>

</table>

</blockquote>



<H2><a name="SecurityPermission">SecurityPermission</a></H2>

<blockquote>

A <code>java.security.SecurityPermission</code> is for security permissions.  
A <code>SecurityPermission</code> contains a name (also referred to as 
a "target name") but no actions list; you either have the named permission 
or you don't.
<P>
The target name is the name of a security configuration parameter (see below). 
Currently the <code>SecurityPermission</code> object is used to guard access 
to the Policy, Security, Provider, Signer, and Identity
objects.
<P>
The following table lists all the possible <code>SecurityPermission</code>
target names,
and for each provides a description of what the permission allows
and a discussion of the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.security.SecurityPermission <br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>createAccessControlContext</td>
  <td>Creation of an AccessControlContext</td>
  <td>This allows someone to instantiate an AccessControlContext with a 
      DomainCombiner. Since DomainCombiners are given a reference to the
      ProtectionDomains currently on the stack, this could potentially 
      lead to a privacy leak if the DomainCombiner is malicious.</td>
</tr>

<tr>
  <td>getDomainCombiner</td>
  <td>Retrieval of an AccessControlContext's DomainCombiner</td>
  <td>This allows someone to query the policy via the getPermissions call, 
      which discloses which permissions would be granted to a given 
      CodeSource. While revealing the policy does not compromise the 
      security of the system, it does provide malicious code with additional 
      information which it may use to better aim an attack. It is wise not 
      to divulge more information than necessary.
</tr>

<tr>
  <td>getPolicy</td>
  <td>Retrieval of the system-wide security policy (specifically, of the
currently-installed Policy object)</td>
  <td>This allows someone to query the policy via the 
<code>getPermissions</code> call,
which discloses which permissions would be granted to a given CodeSource.
While revealing the policy does not compromise the security of
the system, it does provide malicious code with additional information
which it may use to better aim an attack. It is wise
not to divulge more information than necessary.</td>
</tr>

<tr>
  <td>setPolicy</td>
  <td>Setting of the system-wide security policy (specifically,
the Policy object)</td>
  <td>Granting this permission is extremely dangerous, as malicious
code may grant itself all the necessary permissions it needs
to successfully mount an attack on the system.</td>
</tr>

<tr>
  <td>getProperty.{key}</td>
  <td>Retrieval of the security property with the specified key</td>
  <td>Depending on the particular key for which access has
been granted, the code may have access to the list of security
providers, as well as the location of the system-wide and user
security policies.  while revealing this information does not
compromise the security of the system, it does provide malicious
code with additional information which it may use to better aim
an attack.
</td>
</tr>

<tr>
  <td>setProperty.{key}</td>
  <td>Setting of the security property with the specified key</td>
  <td>This could include setting a security provider or defining
the location of the the system-wide security policy.  Malicious
code that has permission to set a new security provider may
set a rogue provider that steals confidential information such
as cryptographic private keys. In addition, malicious code with 
permission to set the location of the system-wide security policy
may point it to a security policy that grants the attacker
all the necessary permissions it requires to successfully mount
an attack on the system.
</td>
</tr>

<tr>
  <td>insertProvider.{provider name}</td>
  <td>Addition of a new provider, with the specified name</td>
  <td>This would allow somebody to introduce a possibly
malicious provider (e.g., one that discloses the private keys passed
to it) as the highest-priority provider. This would be possible
because the Security object (which manages the installed providers)
currently does not check the integrity or authenticity of a provider
before attaching it.</td>
</tr>

<tr>
  <td>removeProvider.{provider name}</td>
  <td>Removal of the specified provider</td>
  <td>This may change the behavior or disable execution of other
parts of the program. If a provider subsequently requested by the
program has been removed, execution may fail. Also, if the removed
provider is not explicitly requested by the rest of the program, but
it would normally be the provider chosen when a cryptography service
is requested (due to its previous order in the list of providers),
a different provider will be chosen instead, or no suitable provider
will be found, thereby resulting in program failure.</td>
</tr>

<tr>
  <td>setSystemScope</td>
  <td>Setting of the system identity scope</td>
  <td>This would allow an attacker to configure the system identity scope with
certificates that should not be trusted, thereby granting applet or
application code signed with those certificates privileges that
would have been denied by the system's original identity scope</td>
</tr>

<tr>
  <td>setIdentityPublicKey</td>
  <td>Setting of the public key for an Identity</td>
  <td>If the identity is marked as "trusted", this allows an attacker to 
introduce a different public key (e.g., its own) that is not trusted
by the system's identity scope, thereby granting applet or
application code signed with that public key privileges that
would have been denied otherwise.</td>
</tr>

<tr>
  <td>setIdentityInfo</td>
  <td>Setting of a general information string for an Identity</td>
  <td>This allows attackers to set the general description for
an identity.  This may trick applications into using a different
identity than intended or may prevent applications from finding a
particular identity.</td>
</tr>

<tr>
  <td>addIdentityCertificate</td>
  <td>Addition of a certificate for an Identity</td>
  <td>This allows attackers to set a certificate for
an identity's public key.  This is dangerous because it affects
the trust relationship across the system. This public key suddenly
becomes trusted to a wider audience than it otherwise would be.</td>
</tr>

<tr>
  <td>removeIdentityCertificate</td>
  <td>Removal of a certificate for an Identity</td>
  <td>This allows attackers to remove a certificate for
an identity's public key. This is dangerous because it affects
the trust relationship across the system. This public key suddenly
becomes considered less trustworthy than it otherwise would be.</td>
</tr>

<tr>
  <td>printIdentity</td>
  <td>Viewing the name of a principal
and optionally the scope in which it is used, and whether
or not it is considered "trusted" in that scope.</td>
  <td>The scope that is printed out may be a filename, in which case
it may convey local system information. For example, here's a sample
printout of an identity named "carol", who is
marked not trusted in the user's identity database:<br>
    carol[/home/luehe/identitydb.obj][not trusted]</td>
</tr>

<tr>
  <td>clearProviderProperties.{provider name}</td>
  <td>"Clearing" of a Provider so that it no longer contains the properties
used to look up services implemented by the provider</td>
  <td>This disables the lookup of services implemented by the provider.
This may thus change the behavior or disable execution of other
parts of the program that would normally utilize the Provider, as
described under the "removeProvider.{provider name}" permission.</td>
</tr>

<tr>
  <td>putProviderProperty.{provider name}</td>
  <td>Setting of properties for the specified Provider</td>
  <td>The provider properties each specify the name and location
of a particular service implemented by the provider. By granting
this permission, you let code replace the service specification
with another one, thereby specifying a different implementation.</td>
</tr>

<tr>
  <td>removeProviderProperty.{provider name}</td>
  <td>Removal of properties from the specified Provider</td>
  <td>This disables the lookup of services implemented by the 
provider. They are no longer accessible due to removal of the properties
specifying their names and locations. This
may change the behavior or disable execution of other
parts of the program that would normally utilize the Provider, as
described under the "removeProvider.{provider name}" permission.</td>
</tr>

<tr>
  <td>getSignerPrivateKey</td>
  <td>Retrieval of a Signer's private key</td>
  <td>It is very dangerous to allow access to a private key; private
keys are supposed to be kept secret. Otherwise, code can use the 
private key to sign various files and claim the signature came from
the Signer.</td>
</tr>

<tr>
  <td>setSignerKeyPair</td>
  <td>Setting of the key pair (public key and private key) for a Signer</td>
  <td>This would allow an attacker to replace somebody else's (the "target's")
keypair with a possibly weaker keypair (e.g., a keypair of a smaller
keysize).  This also would allow the attacker to listen in on encrypted
communication between the target and its peers. The target's peers
might wrap an encryption session key under the target's "new" public
key, which would allow the attacker (who possesses the corresponding
private key) to unwrap the session key and decipher the communication
data encrypted under that session key.</td>
</tr>

</table>

</blockquote>



<H2><a name="SerializablePermission">SerializablePermission</a></H2>

<blockquote>

A <code>java.io.SerializablePermission</code> is for serializable permissions. 
A <code>SerializablePermission</code> 
contains a name (also referred to as a "target name") but
no actions list; you either have the named permission 
or you don't.

<P>
The target name is the name of the Serializable permission (see below).

<P>
The following table lists all the possible <code>SerializablePermission</code>
target names,
and for each provides a description of what the permission allows
and a discussion of the risks of granting code the permission.
<P>

<table border=1 cellpadding=5>
<tr>
<th>java.io.SerializablePermission <br> Target Name</th>
<th>What the Permission Allows</th>
<th>Risks of Allowing this Permission</th>
</tr>

<tr>
  <td>enableSubclassImplementation</td>
  <td>Implementing a subclass of ObjectOutputStream or ObjectInputStream 
to override the default serialization or deserialization, respectively,
of objects</td>
  <td>Code can use this to serialize or
deserialize classes in a purposefully malfeasant manner. For example,
during serialization, malicious code can use this to
purposefully store confidential private field data in a way easily accessible
to attackers. Or, during deserializaiton it could, for example, deserialize 
a class with all its private fields zeroed out.</td>
</tr>

<tr>
  <td>enableSubstitution</td>
  <td>Substitution of one object for another during
serialization or deserialization</td>
  <td>This is dangerous because malicious code
can replace the actual object with one which has incorrect or
malignant data.</td>
</tr>

</table>

</blockquote>



<H2><a name="SocketPermission">SocketPermission</a></H2>

<blockquote>

A <code>java.net.SocketPermission</code> represents access to a 
network via sockets.
A SocketPermission consists of a 
host specification and a set of "actions" specifying ways to
connect to that host. The host is specified as
<pre>
   host = (hostname | IPaddress)[:portrange]
   portrange = portnumber | -portnumber | portnumber-[portnumber]
</pre>
The host is expressed as a DNS name, as a numerical IP address,
or as "localhost" (for the local machine).
The wildcard "*" may be included once in a DNS name host
specification. If it is included, it must be in the leftmost 
position, as in "*.sun.com".
<p>
The port or portrange is optional. A port specification of the 
form "N-", where <i>N</i> is a port number, signifies all ports
numbered <i>N</i> and above, while a specification of the
form "-N" indicates all ports numbered <i>N</i> and below.
<p>
The possible ways to connect to the host are 
<pre>
accept
connect
listen
resolve
</pre>
The "listen" action is only meaningful when used with "localhost". 
The "resolve" (resolve host/ip name service lookups) action is implied
when any of the other actions are present.

<p>As an example of the creation and meaning of SocketPermissions, 
note that if you have the following entry in your policy file:

<pre>
    grant signedBy "mrm" {
      permission java.net.SocketPermission "puffin.eng.sun.com:7777", "connect, 
accept";
    };
</pre>

this causes the following permission object to be generated
and granted to code signed by "mrm."

<pre>
    p1 = new SocketPermission("puffin.eng.sun.com:7777", "connect,accept");
</pre>

<code>p1</code> represents a permission allowing connections to port 7777 on
<code>puffin.eng.sun.com</code>, and also accepting connections on that
port.

<p>Similarly, if you have the following entry in your policy:

<pre>
    grant signedBy "paul" {
      permission java.net.SocketPermission "localhost:1024-", "accept, connect, 
listen";
    };
</pre>

this causes the following permission object to be generated
and granted to code signed by "paul."

<pre>
      p2 = new SocketPermission("localhost:1024-", "accept,connect,listen");
</pre>
    
<code>p2</code> represents a permission allowing accepting connections on,
connecting to, or listening on any port between 1024 and
65535 on the local host.

<p>Note: Granting code permission to accept or make connections to remote
hosts may be dangerous because malevolent code can then more easily
transfer and share confidential data among parties who may not
otherwise have access to the data.


</blockquote>



<H2><a name="SQLPermission">SQLPermission</a></H2>

<blockquote>
The permission for which the <code>SecurityManager</code> will check
 when code that is running in an applet calls one of the 
 <code>setLogWriter</code> methods.  These methods include those in the
 following list.
 <UL>
 <LI><code>DriverManager.setLogWriter</code> <br>
 <LI><code>DriverManager.setLogStream</code> (deprecated)<br>
 <LI><code>javax.sql.DataSource.setLogWriter</code><br>
 <LI><code>javax.sql.ConnectionPoolDataSource.setLogWriter</code><br>
 <LI><code>javax.sql.XADataSource.setLogWriter</code><br>
 </UL>
 If there is no <code>SQLPermission</code> object, this method
 throws a <code>java.lang.SecurityException</code> as a runtime exception.
 <P> 
 A <code>SQLPermission</code> object contains
 a name (also referred to as a "target name") but no actions
 list; there is either a named permission or there is not.
 The target name is the name of the permission (see below). The
 naming convention follows the  hierarchical property naming convention.
 In addition, an asterisk
 may appear at the end of the name, following a ".", or by itself, to
 signify a wildcard match. For example: <code>loadLibrary.*</code>
 or <code>*</code> is valid,
 but <code>*loadLibrary</code> or <code>a*b</code> is not valid.
 <P>
 The following table lists all the possible <code>SQLPermission</code> target na
mes.
 Currently, the only name allowed is <code>setLog</code>.
 The table gives a description of what the permission allows
 and a discussion of the risks of granting code the permission.
 <P>

 <table border=1 cellpadding=5>
 <tr>
 <th>Permission Target Name</th>
 <th>What the Permission Allows</th>
 <th>Risks of Allowing this Permission</th>
 </tr>

 <tr>
   <td>setLog</td>
   <td>Setting of the logging stream</td>
   <td>This is a dangerous permission to grant.
 The contents of the log may contain usernames and passwords,
 SQL statements, and SQL data.</td>
 </tr>
 
 </table>
<p>
 The person running an applet decides what permissions to allow
 and will run the <code>Policy Tool</code> to create an
 <code>SQLPermission</code> in a policy file.  A programmer does
 not use a constructor directly to create an instance of 
<code>SQLPermission</code> but rather uses a tool.
</blockquote>
</blockquote>
<hr>


<h1><a name="PermsAndMethods">Methods and the Permissions They Require</a></h1>

<blockquote>


<p>The following table contains a list of all the Java 2 SDK methods
that require permissions, and for each tells which SecurityManager
method it calls and which permission is checked for by the default
implementation of that SecurityManager method.

<p>Thus, with the default SecurityManager method implementations,
a call to a method in the left-hand column can only be successful 
if the permission specified in the corresponding entry in the 
right-hand column is allowed by the policy
currently in effect. For example, the following row:

<p>
<table border=1 cellpadding=5>
<tr>
	<th>Method</th>
	<th>SecurityManager Method Called</th>
	<th>Permission</th>
</tr>
<tr>
<td>
<pre>
java.awt.Toolkit
    getSystemEventQueue(); 
</td>
<td>checkAwtEventQueueAccess
<td>java.awt.AWTPermission "accessEventQueue";</td>
</pre>
</tr>
</table>

<p>specifies that a call to the <code>getSystemEventQueue</code> method
in the <code>java.awt.Toolkit</code> class results in a call to the
<code>checkAwtEventQueueAccess</code> SecurityManager method,
which can only be successful if the following
permission is granted to code on the call stack:

<pre>
  java.awt.AWTPermission "accessEventQueue";
</pre>


<p> The convention of:
<p>
<table border=1 cellpadding=5>
<tr>
	<th>Method</th>
	<th>SecurityManager Method Called</th>
	<th>Permission</th>
</tr>
<tr>
	<td>
<pre>
 some.package.class
   public static void someMethod(String foo); 
</pre>
	</td>
               <td>checkXXX
	<td>SomePermission "{foo}";</td>
</tr>
</table>
<p>
means the runtime value of <code>foo</code> replaces the string <code>{foo}</code>
in the permission name.

<p>As an example, here is one table entry:

<p>
<table border=1 cellpadding=5>
<tr>
	<th>Method</th>
	<th>SecurityManager Method Called</th>
	<th>Permission</th>
</tr>
<tr>
<td>
<pre>
java.io.FileInputStream
    FileInputStream(String name) 
</pre>
	</td>
 <td>checkRead(String)
<td>java.io.FilePermission "{name}", "read";</td>

</tr>
</table>

<p>If the <code>FileInputStream</code> method (in this case, a constructor) is 
called with "/test/MyTestFile" as the <code>name</code> argument, as in

<pre>
  FileInputStream("/test/MyTestFile");
</pre>

then in order for the call to succeed, the following permission must
be set in the current policy, allowing read access to the file "/test/MyTestFile":

<pre>
  java.io.FilePermission "/test/MyTestFile", "read";
</pre>

More specifically, the permission must either be explicitly set,
as above, or implied by another permission, such as the following:

<pre>
  java.io.FilePermission "/test/*", "read";
</pre>

which allows read access to any files in the "/test" directory.

<p> In some cases, a term in braces is not
exactly the same as the name of a specific method argument but is meant to represent
the relevant value. Here is an example:

<p>
<table border=1 cellpadding=5>
<tr>
	<th>Method</th>
	<th>SecurityManager Method Called</th>
	<th>Permission</th>
</tr>
<tr>
<td>
<pre>
java.net.DatagramSocket
  public synchronized void 
      receive(DatagramPacket p);
</pre>
<td>checkAccept({host}, {port})
<td>java.net.SocketPermission "{host}:{port}", "accept";</td>
</tr>
</table>

<p>Here, the appropriate host and port values are calculated by the
<code>receive</code> method and passed to <code>checkAccept</code>.

<p>In most cases, just the name of the SecurityManager method called
is listed. Where the method is one of multiple methods of the same
name, the argument types are also listed, for example for
<code>checkRead(String)</code> and 
<code>checkRead(FileDescriptor)</code>.  In other cases where
arguments may be relevant, they are also listed.

<p>The following table is ordered by package name. That is, the methods
in classes in the <code>java.awt</code> package are listed first, 
followed by methods in classes in the <code>java.io</code> package, 
and so on.

</blockquote>



<p>
<p>
<table border=1 cellpadding=5>
<center><font size="+2"><b>Methods and the Permissions They Require</b></font>
</center><br>
<tr>
	<th>Method</th>
	<th>SecurityManager Method Called</th>
	<th>Permission</th>
</tr>

<tr>
<td>
<pre>
java.awt.Graphics2d
  public abstract void 
    setComposite(Composite comp)
</pre>
<td>checkPermission
<td>java.awt.AWTPermission "readDisplayPixels"
if this Graphics2D context is drawing to a
Component on the display screen and the
Composite is a custom object rather than an
instance of the AlphaComposite class.
Note: The setComposite method is actually
abstract and thus can't invoke security checks.
Each actual implementation of the method should call
the java.lang.SecurityManager checkPermission method
with a 
java.awt.AWTPermission("readDisplayPixels") permission
under the conditions noted.
<p>
</td>
</tr>

<tr>
<td>
<pre>
java.awt.Robot
  public Robot()
  public Robot(GraphicsDevice screen)
</pre>
<td>checkPermission
<td>java.awt.AWTPermission "createRobot"
</tr>

<tr>
<td>
<pre>
java.awt.Toolkit
  public void addAWTEventListener(
          AWTEventListener listener, 
          long eventMask)
  public void removeAWTEventListener(
     AWTEventListener listener)
</pre>
<td>checkPermission
<td>java.awt.AWTPermission "listenToAllAWTEvents"<p>
</td>
</tr>

<tr>
<td>
<pre>
java.awt.Toolkit
  public abstract PrintJob getPrintJob(
           Frame frame, String jobtitle,
           Properties props)
</pre>
<td>checkPrintJobAccess
<td>java.lang.RuntimePermission "queuePrintJob"<p>
Note: The getPrintJob method is actually
abstract and thus can't invoke security checks.
Each actual implementation of the method should call
the java.lang.SecurityManager checkPrintJobAccess method,
which is successful only if the 
java.lang.RuntimePermission "queuePrintJob"
permission is currently allowed.
</td>
</tr>

<tr>
<td>
<pre>
java.awt.Toolkit
  public abstract Clipboard 
                    getSystemClipboard()
</pre>
<td>checkSystemClipboardAccess
<td>java.awt.AWTPermission "accessClipboard"<p>
Note: The getSystemClipboard method is actually
abstract and thus can't invoke security checks.
Each actual implementation of the method should call
the java.lang.SecurityManager checkSystemClipboardAccess 
method, which is successful only if the 
java.awt.AWTPermission "accessClipboard"
permission is currently allowed.
</td>
</tr>

<tr>
<td>
<pre>
java.awt.Toolkit
  public final EventQueue 
               getSystemEventQueue()
</pre>
<td>checkAwtEventQueueAccess
<td>java.awt.AWTPermission "accessEventQueue"</td>
</tr>

<tr>
<td>
<pre>
java.awt.Window
  Window()
</pre>
<td>checkTopLevelWindow
<td>If java.awt.AWTPermission "showWindowWithoutWarningBanner"
is set, the window will be displayed without a banner warning that
the window was created by an applet. It it's not set, such a banner
will be displayed.</td>
</tr>

<tr>
<td>
<pre>
java.beans.Beans
  public static void setDesignTime(
                 boolean isDesignTime)
  public static void setGuiAvailable(
                 boolean isGuiAvailable)

java.beans.Introspector
  public static synchronized void 
    setBeanInfoSearchPath(String path[])

java.beans.PropertyEditorManager
  public static void registerEditor(
                 Class targetType, 
                 Class editorClass)
  public static synchronized void 
    setEditorSearchPath(String path[])
</pre>
<td>checkPropertiesAccess
<td>java.util.PropertyPermission "*", "read,write"</td>
</tr>

<tr>
<td>
<pre>
java.io.File
  public boolean delete()
  public void deleteOnExit()
</pre>
<td>checkDelete(String)
<td>java.io.FilePermission "{name}", "delete"</td>
</tr>

<tr>
<td>
<pre>
java.io.FileInputStream
  FileInputStream(FileDescriptor fdObj)
</pre>
<td>checkRead(FileDescriptor)
<td>java.lang.RuntimePermission "readFileDescriptor"</td>
</tr>

<tr>
<td>
<pre>
java.io.FileInputStream
  FileInputStream(String name)
  FileInputStream(File file)

java.io.File
  public boolean exists()
  public boolean canRead()
  public boolean isFile()
  public boolean isDirectory()
  public boolean isHidden()
  public long lastModified()
  public long length()
  public String[] list()
  public String[] list(
           FilenameFilter filter)
  public File[] listFiles()
  public File[] listFiles(
           FilenameFilter filter)
  public File[] listFiles(
           FileFilter filter)
      
java.io.RandomAccessFile
  RandomAccessFile(String name, String mode)
  RandomAccessFile(File file, String mode)
      (where mode is "r" in both of these)
</pre>
<td>checkRead(String)
<td>java.io.FilePermission "{name}", "read"</td>
</tr>

<tr>
<td>
<pre>
java.io.FileOutputStream
  FileOutputStream(FileDescriptor fdObj)
</pre>
<td>checkWrite(FileDescriptor)
<td>java.lang.RuntimePermission "writeFileDescriptor"</td>
</tr>

<tr>
<td>
<pre>
java.io.FileOutputStream 
  FileOutputStream(File file)
  FileOutputStream(String name)
  FileOutputStream(String name, 
                   boolean append)

java.io.File
  public boolean canWrite()
  public boolean createNewFile()
  public static File createTempFile(
          String prefix, String suffix)
  public static File createTempFile(
          String prefix,  String suffix, 
          File directory)
  public boolean mkdir()
  public boolean mkdirs()
  public boolean renameTo(File dest)
  public boolean setLastModified(long time)
  public boolean setReadOnly()
</pre>
<td>checkWrite(String)
<td>java.io.FilePermission "{name}", "write"</td>
</tr>

<tr>
<td>
<pre>
java.io.ObjectInputStream
  protected final boolean 
    enableResolveObject(boolean enable);

java.io.ObjectOutputStream
  protected final boolean 
    enableReplaceObject(boolean enable)
</pre>
<td>checkPermission
<td>java.io.SerializablePermission "enableSubstitution"</td>
</tr>

<tr>
<td>
<pre>
java.io.ObjectInputStream
  protected ObjectInputStream()

java.io.ObjectOutputStream
  protected ObjectOutputStream()
</pre>
<td>checkPermission
<td>java.io.SerializablePermission "enableSubclassImplementation"</td>
</tr>

<tr>
<td>
<pre>
java.io.RandomAccessFile
  RandomAccessFile(String name, String mode)
      (where mode is "rw")
</pre>
<td>checkRead(String) and checkWrite(String)
<td>java.io.FilePermission "{name}", "read,write"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
  public static Class forName(
     String name, boolean initialize, 
     ClassLoader loader)
</pre>
<td>checkPermission
<td> If <code>loader</code> is null, and 
the caller's class loader is not null, then 
java.lang.RuntimePermission("getClassLoader")
</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
  public Class[] getClasses()
</pre>
<td>For this class and each of its superclasses,
checkMemberAccess(this, Member.DECLARED) is called
and, if the class is in a package, checkPackageAccess({pkgName}) is called.
<td>Default checkMemberAccess does not require any permissions if
"this" class's classloader is the same as that of the caller. 
Otherwise, it
requires java.lang.RuntimePermission "accessDeclaredMembers".
If the class is in a package,
java.lang.RuntimePermission "accessClassInPackage.{pkgName}"
is also required.
</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
  public ClassLoader getClassLoader()
</pre>
<td>checkPermission
<td>If the caller's class loader is null, or is the same as or an ancestor of
the class loader for the class whose class loader is being requested, no
permission is needed. Otherwise, <br>
java.lang.RuntimePermission "getClassLoader" <br>
is required.</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
  public Class[] getDeclaredClasses()
  public Field[] getDeclaredFields()
  public Method[] getDeclaredMethods()
  public Constructor[] 
    getDeclaredConstructors()
  public Field getDeclaredField(
                       String name)
  public Method getDeclaredMethod(...)
  public Constructor 
    getDeclaredConstructor(...)
</pre>
<td>checkMemberAccess(this, Member.DECLARED)
and, if this class is in a package, checkPackageAccess({pkgName})
<td>Default checkMemberAccess does not require any permissions if
"this" class's classloader is the same as that of the caller. Otherwise, it
requires java.lang.RuntimePermission "accessDeclaredMembers".
If this class is in a package,
java.lang.RuntimePermission "accessClassInPackage.{pkgName}"
is also required.
</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
  public Field[] getFields()
  public Method[] getMethods()
  public Constructor[] getConstructors()
  public Field getField(String name)
  public Method getMethod(...)
  public Constructor getConstructor(...)
</pre>
<td>checkMemberAccess(this, Member.PUBLIC)
and, if class is in a package, checkPackageAccess({pkgName})
<td>Default checkMemberAccess does not require any permissions when
the access type is Member.PUBLIC. If this class is in a package,
java.lang.RuntimePermission "accessClassInPackage.{pkgName}"
is required.
</td>
</tr>

<tr>
<td>
<pre>
java.lang.Class
   public ProtectionDomain 
            getProtectionDomain()
</pre>
<td>checkPermission
<td>java.lang.RuntimePermission "getProtectionDomain"</td>
</tr>

<tr>
<td>
<pre>
java.lang.ClassLoader
  ClassLoader()
  ClassLoader(ClassLoader parent)
</pre>
<td>checkCreateClassLoader
<td>java.lang.RuntimePermission "createClassLoader"</td>
</tr>

<tr>
<td>
<pre>
java.lang.ClassLoader
  public static ClassLoader 
           getSystemClassLoader()
  public ClassLoader getParent()
</pre>
<td>checkPermission
<td>If the caller's class loader is null, or is the same as or an ancestor of
the class loader for the class whose class loader is being requested, no
permission is needed. Otherwise, <br>
java.lang.RuntimePermission "getClassLoader" <br>
is required.</td>
</tr>

<tr>
<td>
<pre>
java.lang.Runtime
  public Process exec(String command)
  public Process exec(String command, 
                      String envp[])
  public Process exec(String cmdarray[])
  public Process exec(String cmdarray[], 
                      String envp[])
</pre>
<td>checkExec
<td>java.io.FilePermission "{command}", "execute"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Runtime
  public void exit(int status)
  public static void 
      runFinalizersOnExit(boolean value)
java.lang.System
  public static void exit(int status)
  public static void 
      runFinalizersOnExit(boolean value)
</pre>
<td>checkExit(status) where status is 0 for runFinalizersOnExit
<td>java.lang.RuntimePermission "exitVM"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Runtime
  public void addShutdownHook(Thread hook)
  public boolean removeShutdownHook(Thread hook)
</pre>
</td>
<td>checkPermission</td>
<td>java.lang.RuntimePermission "shutdownHooks"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Runtime
  public void load(String lib)
  public void loadLibrary(String lib)
java.lang.System
  public static void load(String filename)
  public static void loadLibrary(
                          String libname)
</pre>
<td>checkLink({libName}) where {libName} is the
lib, filename or libname argument
<td>java.lang.RuntimePermission "loadLibrary.{libName}"</td>
</tr>

<tr>
<td>
<pre>
java.lang.SecurityManager methods
</pre>
<td>checkPermission
<td>See the <a href = "#SecMgrChecks">next table</a>.</td>
</tr>

<tr>
<td>
<pre>
java.lang.System
  public static Properties 
      getProperties()
  public static void 
      setProperties(Properties props)
</pre>
<td>checkPropertiesAccess
<td>java.util.PropertyPermission "*", "read,write"</td>
</tr>

<tr>
<td>
<pre>
java.lang.System
  public static String 
      getProperty(String key)
  public static String 
      getProperty(String key, String def)
</pre>
<td>checkPropertyAccess
<td>java.util.PropertyPermission "{key}", "read"</td>
</tr>

<tr>
	<td>
<pre>
java.lang.System
  public static void setIn(InputStream in)
  public static void setOut(PrintStream out)
  public static void setErr(PrintStream err)
</pre>
<td>checkPermission
	</td>
	<td>java.lang.RuntimePermission "setIO"</td>
</tr>

<tr>
<td>
<pre>
java.lang.System
  public static String 
    setProperty(String key, String value)
</pre>
<td>checkPermission
<td>java.util.PropertyPermission "{key}", "write"</td>
</tr>

<tr>
<td>
<pre>
java.lang.System
  public static synchronized void 
    setSecurityManager(SecurityManager s)
</pre>
<td>checkPermission
<td>java.lang.RuntimePermission "setSecurityManager"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Thread
  public ClassLoader getContextClassLoader()
</pre>
<td>checkPermission
<td>If the caller's class loader is null, or is the same as or an ancestor of
the context class loader for the thread whose context class loader is being 
requested, no permission is needed. Otherwise, <br>
java.lang.RuntimePermission "getClassLoader" <br>
is required.</td>
</tr>

<tr>
<td>
<pre>
java.lang.Thread
  public void setContextClassLoader
                      (ClassLoader cl)
</pre>
<td>checkPermission
<td>java.lang.RuntimePermission "setContextClassLoader"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Thread
  public final void checkAccess()
  public void interrupt()
  public final void suspend()
  public final void resume()
  public final void setPriority
                     (int newPriority)
  public final void setName(String name)
  public final void setDaemon(boolean on)
</pre>
<td>checkAccess(this)
<td>java.lang.RuntimePermission "modifyThread"</td>
</tr>

<tr>
<td>
<pre>
java.lang.Thread
  public static int 
      enumerate(Thread tarray[])
</pre>
<td>checkAccess({threadGroup})
<td>java.lang.RuntimePermission "modifyThreadGroup"</td>
</tr>


<tr>
<td>
<pre>
java.lang.Thread
  public final void stop()
</pre>
<td>checkAccess(this). Also checkPermission if
the current  thread is trying to stop a thread other than itself.
<td> 
java.lang.RuntimePermission "modifyThread". <br>
Also java.lang.RuntimePermission "stopThread" if
the current  thread is trying to stop a thread other than itself.
</td>
</tr>


<tr>
<td>
<pre>
java.lang.Thread
  public final synchronized void 
                    stop(Throwable obj)
</pre>
<td>checkAccess(this). Also checkPermission if
the current  thread is trying to stop a thread other than itself
or obj is not an instance of ThreadDeath.
<td> 
java.lang.RuntimePermission "modifyThread". <br>
Also java.lang.RuntimePermission "stopThread" if
the current  thread is trying to stop a thread other than itself
or obj is not an instance of ThreadDeath.
</td>
</tr>


<tr>
<td>
<pre>
java.lang.Thread
  Thread()
  Thread(Runnable target)
  Thread(String name)
  Thread(Runnable target, String name)

java.lang.ThreadGroup
  ThreadGroup(String name)
  ThreadGroup(ThreadGroup parent, 
              String name)
</pre>
<td>checkAccess({parentThreadGroup}) 
<td>java.lang.RuntimePermission "modifyThreadGroup"</td>
</tr>


<tr>
<td>
<pre>
java.lang.Thread
  Thread(ThreadGroup group, ...)

java.lang.ThreadGroup
  public final void checkAccess()
  public int enumerate(Thread list[])
  public int enumerate(Thread list[],
      boolean recurse)
  public int enumerate(ThreadGroup list[])
  public int enumerate(ThreadGroup list[],
      boolean recurse)
  public final ThreadGroup getParent()
  public final void 
      setDaemon(boolean daemon)
  public final void setMaxPriority(int pri)
  public final void suspend()
  public final void resume()
  public final void destroy()
</pre>
<td>checkAccess(this) for ThreadGroup methods, or
checkAccess(group) for Thread methods
<td>java.lang.RuntimePermission "modifyThreadGroup"</td>
</tr>


<tr>
<td>
<pre>
java.lang.ThreadGroup
  public final void interrupt()
</pre>
<td>checkAccess(this)
<td>Requires java.lang.RuntimePermission "modifyThreadGroup".<br>
Also requires
java.lang.RuntimePermission "modifyThread", since 
the java.lang.Thread interrupt() method
is called for each thread in the thread group and in all of its subgroups.
See the Thread interrupt() method.</td>
</tr>


<tr>
<td>
<pre>
java.lang.ThreadGroup
  public final void stop()
</pre>
<td>checkAccess(this)
<td>Requires java.lang.RuntimePermission "modifyThreadGroup".<br>
Also requires
java.lang.RuntimePermission "modifyThread" and possibly
java.lang.RuntimePermission "stopThread", since the java.lang.Thread stop() method
is called for each thread in the thread group and in all of its subgroups.
See the Thread stop() method.</td>
</tr>


<tr>
<td>
<pre>
java.lang.reflect.AccessibleObject
  public static void setAccessible(...)
  public void setAccessible(...)
</pre>
<td>checkPermission
<td>java.lang.reflect.ReflectPermission "suppressAccessChecks"</td>
</tr>

<tr>
<td>
<pre>
java.net.Authenticator
  public static PasswordAuthentication
       requestPasswordAuthentication(
             InetAddress addr,
             int port,
             String protocol,
             String prompt,
             String scheme)
</pre>
<td>checkPermission
<td>java.net.NetPermission 
         "requestPasswordAuthentication"</td>
</tr>

<tr>
<td>
<pre>
java.net.Authenticator
  public static void 
      setDefault(Authenticator a)
</pre>
<td>checkPermission
<td>java.net.NetPermission "setDefaultAuthenticator"</td>
</tr>

<tr>
<td>
<pre>
java.net.MulticastSocket
  public void 
      joinGroup(InetAddress mcastaddr)
  public void 
      leaveGroup(InetAddress mcastaddr)
</pre>
<td>checkMulticast(InetAddress)
<td>java.net.SocketPermission(
  mcastaddr.getHostAddress(), "accept,connect")</td>
</tr>

<tr>
<td>
<pre>
java.net.DatagramSocket
  public void send(DatagramPacket p)
</pre>
<td>checkMulticast(p.getAddress()) or 
checkConnect(<br>
p.getAddress().getHostAddress(),  p.getPort())
<td>
if (p.getAddress().isMulticastAddress()) {<br>
  java.net.SocketPermission(<br>
    (p.getAddress()).getHostAddress(), "accept,connect")<br>
}<br>
else {<br>
  port = p.getPort();<br>
  host = p.getAddress().getHostAddress();<br>
  if (port == -1) java.net.SocketPermission "{host}","resolve";<br>
  else java.net.SocketPermission "{host}:{port}","connect"<br>
}
</td>
</tr>

<tr>
<td>
<pre>
java.net.MulticastSocket
  public synchronized void 
      send(DatagramPacket p, byte ttl)
</pre>
<td>checkMulticast(p.getAddress(), ttl) or 
checkConnect(<br>
p.getAddress().getHostAddress(),  p.getPort())
<td>
if (p.getAddress().isMulticastAddress()) {<br>
  java.net.SocketPermission(<br>
    (p.getAddress()).getHostAddress(), "accept,connect")<br>
}<br>
else {<br>
  port = p.getPort();<br>
  host = p.getAddress().getHostAddress();<br>
  if (port == -1) java.net.SocketPermission "{host}","resolve";<br>
  else java.net.SocketPermission "{host}:{port}","connect"<br>
}
</td>
</tr>

<tr>
<td>
<pre>
java.net.InetAddress
  public String getHostName()
  public static InetAddress[]
                  getAllByName(String host)
  public static InetAddress getLocalHost()

java.net.DatagramSocket
  public InetAddress getLocalAddress()
</pre>
<td>checkConnect({host}, -1)
<td>java.net.SocketPermission "{host}", "resolve"</td>
</tr>

<tr>
<td>
<pre>
java.net.ServerSocket
  ServerSocket(...)

java.net.DatagramSocket
  DatagramSocket(...)

java.net.MulticastSocket
  MulticastSocket(...)
</pre>
<td>checkListen({port})
<td>if (port == 0)
            java.net.SocketPermission "localhost:1024-","listen";<br>
        else
	    java.net.SocketPermission "localhost:{port}","listen"
</td>
</tr>

<tr>
<td>
<pre>
java.net.ServerSocket
  public Socket accept()
  protected final void implAccept(Socket s)
</pre>
<td>checkAccept({host}, {port})
<td>java.net.SocketPermission "{host}:{port}", "accept"</td>
</tr>

<tr>
<td>
<pre>
java.net.ServerSocket
  public static synchronized void 
      setSocketFactory(...)

java.net.Socket
  public static synchronized void
      setSocketImplFactory(...)

java.net.URL
  public static synchronized void
      setURLStreamHandlerFactory(...)

 java.net.URLConnection
   public static synchronized void
      setContentHandlerFactory(...)
   public static void 
      setFileNameMap(FileNameMap map)

java.net.HttpURLConnection
   public static void 
       setFollowRedirects(boolean set)

java.rmi.activation.ActivationGroup
  public static synchronized
    	ActivationGroup createGroup(...)
  public static synchronized void 
      setSystem(ActivationSystem system)

java.rmi.server.RMISocketFactory
   public synchronized static void
      setSocketFactory(...)
</pre>
<td>checkSetFactory
<td>java.lang.RuntimePermission "setFactory"</td>
</tr>

<tr>
<td>
<pre>
java.net.Socket
  Socket(...)
</pre>
<td>checkConnect({host}, {port})
<td>java.net.SocketPermission "{host}:{port}", "connect"</td>
</tr>

<tr>
<td>
<pre>
java.net.DatagramSocket
  public synchronized void 
      receive(DatagramPacket p)
</pre>
<td>checkAccept({host}, {port})
<td>java.net.SocketPermission "{host}:{port}", "accept"</td>
</tr>

<tr>
<td>
<pre>
java.net.URL
  URL(...)
</pre>
<td>checkPermission
<td>java.net.NetPermission "specifyStreamHandler"</td>
</tr>

<tr>
<td>
<pre>
java.net.URLClassLoader
  URLClassLoader(...)
</pre>
<td>checkCreateClassLoader
<td>java.lang.RuntimePermission "createClassLoader"</td>
</tr>

<tr>
<td>
<pre>
java.security.AccessControlContext
  public AccessControlContext(AccessControlContext acc,
				DomainCombiner combiner)
  public DomainCombiner getDomainCombiner()
</pre>
<td>checkPermission
<td>java.security.SecurityPermission "createAccessControlContext"
</tr>

<tr>
<td>
<pre>
java.security.Identity
  public void addCertificate(...)

</pre>
<td>checkSecurityAccess(<br>
"addIdentityCertificate")
<td>java.security.SecurityPermission "addIdentityCertificate"</td>
</tr>

<tr>
<td>
<pre>
java.security.Identity
  public void removeCertificate(...)
</pre>
<td>checkSecurityAccess(<br>
"removeIdentityCertificate")</td>
<td>java.security.SecurityPermission "removeIdentityCertificate"</td>
</tr>

<tr>
<td>
<pre>
java.security.Identity
  public void setInfo(String info)
</pre>
<td>checkSecurityAccess(<br>
"setIdentityInfo")</td>
<td>java.security.SecurityPermission "setIdentityInfo"</td>
</tr>

<tr>
<td>
<pre>
java.security.Identity
  public void setPublicKey(PublicKey key)
</pre>
<td>checkSecurityAccess(<br>
"setIdentityPublicKey")</td>
<td>java.security.SecurityPermission "setIdentityPublicKey"</td>
</tr>

<tr>
<td>
<pre>
java.security.Identity
  public String toString(...)
</pre>
<td>checkSecurityAccess(<br>
"printIdentity")</td>
<td>java.security.SecurityPermission "printIdentity"</td>
</tr>

<tr>
<td>
<pre>
java.security.IdentityScope
  protected static void setSystemScope()
</pre>
<td>checkSecurityAccess(<br>
"setSystemScope")</td>
<td>java.security.SecurityPermission "setSystemScope"</td>
</tr>

<tr>
<td>
<pre>
java.security.Permission
  public void checkGuard(Object object) 
</pre>
<td>checkPermission(this)
<td>this Permission object is the permission checked</td>
</tr>

<tr>
<td>
<pre>
java.security.Policy
  public static Policy getPolicy()
</pre>
<td>checkPermission
<td>java.security.SecurityPermission "getPolicy"</td>
</tr>

<tr>
<td>
<pre>
java.security.Policy
  public static void 
      setPolicy(Policy policy);
</pre>
<td>checkPermission
<td>java.security.SecurityPermission "setPolicy"</td>
</tr>

<tr>
<td>
<pre>
java.security.Provider
  public synchronized void clear()
</pre>
<td>checkSecurityAccess(<br>
"clearProviderProperties."+{name})
<td>java.security.SecurityPermission "clearProviderProperties.{name}"
where <i>name</i> is the provider name.
</td>
</tr>

<tr>
<td>
<pre>
java.security.Provider
  public synchronized Object 
      put(Object key, Object value)
</pre>
<td>checkSecurityAccess(<br>
"putProviderProperty."+{name})
<td>java.security.SecurityPermission "putProviderProperty.{name}"
where <i>name</i> is the provider name.
</td>
</tr>

<tr>
<td>
<pre>
java.security.Provider
  public synchronized Object 
      remove(Object key)
</pre>
<td>checkSecurityAccess(<br>
"removeProviderProperty."+{name})
<td>java.security.SecurityPermission "removeProviderProperty.{name}"
where <i>name</i> is the provider name.
</td>
</tr>

<tr>
<td>
<pre>
java.security.SecureClassLoader
  SecureClassLoader(...)
</pre>
<td>checkCreateClassLoader
<td>java.lang.RuntimePermission "createClassLoader"</td>
</tr>

<tr>
<td>
<pre>
java.security.Security
  public static void getProperty(String key)
</pre>
<td>checkPermission
<td>java.security.SecurityPermission "getProperty.{key}"</td>
</tr>

<tr>
<td>
<pre>
java.security.Security
  public static int 
      addProvider(Provider provider)
  public static int 
      insertProviderAt(Provider provider,
                       int position);
</pre>
<td>checkSecurityAccess(<br>
"insertProvider."+provider.getName())
<td>java.security.SecurityPermission "insertProvider.{name}"</td>
</tr>

<tr>
<td>
<pre>
java.security.Security
  public static void 
      removeProvider(String name)
</pre>
<td>checkSecurityAccess(<br>
"removeProvider."+name)
<td>java.security.SecurityPermission "removeProvider.{name}"</td>
</tr>

<tr>
<td>
<pre>
java.security.Security
  public static void 
    setProperty(String key, String datum)
</pre>
<td>checkSecurityAccess(<br>
"setProperty."+key)
<td>java.security.SecurityPermission "setProperty.{key}"</td>
</tr>

<tr>
<td>
<pre>
java.security.Signer
  public PrivateKey getPrivateKey()
</pre>
<td>checkSecurityAccess(<br>
"getSignerPrivateKey")
<td>java.security.SecurityPermission "getSignerPrivateKey"</td>
</tr>

<tr>
<td>
<pre>
java.security.Signer
  public final void 
      setKeyPair(KeyPair pair) 
</pre>
<td>checkSecurityAccess(<br>
"setSignerKeypair")
<td>java.security.SecurityPermission "setSignerKeypair"</td>
</tr>

<tr>
<td>
<pre>
java.sql.DriverManager
  public static synchronized void 
      setLogWriter(PrintWriter out) 
</pre>
<td>checkPermission
<td>java.sql.SQLPermission "setLog"</td>
</tr>

<tr>
<td>
<pre>
java.sql.DriverManager
  public static synchronized void 
      setLogStream(PrintWriter out) 
</pre>
<td>checkPermission
<td>java.sql.SQLPermission "setLog"</td>
</tr>

<tr>
<td>
<pre>
java.util.Locale
  public static synchronized void 
            setDefault(Locale newLocale)
</pre>
<td>checkPermission
<td>java.util.PropertyPermission "user.language","write"</td>
</tr>

<tr>
<td>
<pre>
java.util.zip.ZipFile
  ZipFile(String name)
</pre>
<td>checkRead
<td>java.io.FilePermission "{name}","read"</td>
</tr>

</table>

<p>

<br>
<hr>


<h1><a name="SecMgrChecks">java.lang.SecurityManager Method Permission Checks</a></h1>

<p>This table shows which permissions are checked for by the 
default implementations of the 
<code>java.lang.SecurityManager</code> methods.

<p>Each of the specified <code>check</code> methods calls the 
<code>SecurityManager</code>
<code>checkPermission</code> method with the specified permission, 
except for the <code>checkConnect</code> and <code>checkRead</code>
methods that take a context argument.
Those methods expect the context to be an <code>AccessControlContext</code>
and they call the context's <code>checkPermission</code> method 
with the specified permission.

<br>
<br>

<table border=1 cellpadding=5>

<tr>
	<th>Method</th>
	<th>Permission</th>
</tr>

<tr>
      <td>public void checkAccept(String host, int port);</td>
      <td>java.net.SocketPermission "{host}:{port}", "accept";</td>
</tr>
<tr>
      <td>public void checkAccess(Thread g);</td>
      <td>java.lang.RuntimePermission "modifyThread");</td>
</tr>
<tr>
      <td>public void checkAccess(ThreadGroup g);</td>
      <td>java.lang.RuntimePermission "modifyThreadGroup");</td>
</tr>
<tr>
      <td>public void checkAwtEventQueueAccess();</td>
      <td>java.awt.AWTPermission "accessEventQueue";</td>
</tr>
<tr>
      <td>public void checkConnect(String host, int port);</td>
      <td>if (port == -1) java.net.SocketPermission "{host}","resolve"; <br>
        else java.net.SocketPermission "{host}:{port}","connect";</td>
</tr>
<tr>
      <td>public void checkConnect(String host, int port, Object context);</td>
      <td>if (port == -1) java.net.SocketPermission "{host}","resolve"; <br>
        else java.net.SocketPermission "{host}:{port}","connect";</td>
</tr>
<tr>
	<td>public void checkCreateClassLoader();</td>
	<td>java.lang.RuntimePermission "createClassLoader";</td>
</tr>
<tr>
      <td>public void checkDelete(String file);</td>
      <td>java.io.FilePermission "{file}", "delete";</td>
</tr>
<tr>
      <td>public void checkExec(String cmd);</td>
    <td>if cmd is an absolute path: java.io.FilePermission "{cmd}", "execute";<br>
        else java.io.FilePermission "-", "execute";</td>
</tr>
<tr>
      <td>public void checkExit(int status);</td>
      <td>java.lang.RuntimePermission "exitVM");</td>
</tr>
<tr>
      <td>public void checkLink(String lib);</td>
      <td>java.lang.RuntimePermission "loadLibrary.{lib}";</td>
</tr>
<tr>
      <td>public void checkListen(int port);</td>
      <td>if (port == 0)
            java.net.SocketPermission "localhost:1024-","listen";<br>
        else
	    java.net.SocketPermission "localhost:{port}","listen";</td>
</tr>
<tr>
      <td>public void checkMemberAccess(Class clazz, int which);</td>
	<td>
<pre>
if (which != Member.PUBLIC) {
  if (currentClassLoader() != clazz.getClassLoader()) {
    checkPermission(
      new java.lang.RuntimePermission("accessDeclaredMembers"));
  }
}
</pre>
</td>
</tr>
<tr>
      <td>public void checkMulticast(InetAddress maddr);</td>
      <td>java.net.SocketPermission(maddr.getHostAddress(),"accept,connect");</td>
</tr>
<tr>
      <td>public void checkMulticast(InetAddress maddr, byte ttl);</td>
      <td>java.net.SocketPermission(maddr.getHostAddress(),"accept,connect");</td>
</tr>
<tr>
      <td>public void checkPackageAccess(String pkg);</td>
      <td>java.lang.RuntimePermission "accessClassInPackage.{pkg}";</td>
</tr>
<tr>
      <td>public void checkPackageDefinition(String pkg);</td>
      <td>java.lang.RuntimePermission "defineClassInPackage.{pkg}";</td>
</tr>
<tr>
      <td>public void checkPrintJobAccess();</td>
      <td>java.lang.RuntimePermission "queuePrintJob";</td>
</tr>
<tr>
      <td>public void checkPropertiesAccess();</td>
      <td>java.util.PropertyPermission "*", "read,write";</td>
</tr>
<tr>
      <td>public void checkPropertyAccess(String key);</td>
      <td>java.util.PropertyPermission "{key}", "read,write";</td>
</tr>
<tr>
      <td>public void checkRead(FileDescriptor fd);</td>
      <td>java.lang.RuntimePermission "readFileDescriptor";</td>
</tr>
<tr>
      <td>public void checkRead(String file);</td>
      <td>java.io.FilePermission "{file}", "read";</td>
</tr>
<tr>
      <td>public void checkRead(String file, Object context);</td>
      <td>java.io.FilePermission "{file}", "read";</td>
</tr>
<tr>
      <td>public void checkSecurityAccess(String action);</td>
      <td>java.security.SecurityPermission "{action}";</td>
</tr>
<tr>
      <td>public void checkSetFactory();</td>
      <td>java.lang.RuntimePermission "setFactory";</td>
</tr>
<tr>
      <td>public void checkSystemClipboardAccess();</td>
      <td>java.awt.AWTPermission "accessClipboard";</td>
</tr>
<tr>
      <td>public boolean checkTopLevelWindow(Object window);</td>
      <td>java.awt.AWTPermission "showWindowWithoutWarningBanner";</td>
</tr>
<tr>
      <td>public void checkWrite(FileDescriptor fd);</td>
      <td>java.lang.RuntimePermission "writeFileDescriptor";</td>
</tr>
<tr>
      <td>public void checkWrite(String file);</td>
      <td>java.io.FilePermission "{file}", "write";</td>
</tr>

<tr>
      <td>public SecurityManager();</td>
      <td>java.lang.RuntimePermission "createSecurityManager";</td>
</tr>

</table>

<p>


<!-- Body text ends here -->

<!-- ============================================================== -->
<HR SIZE=3 NOSHADE>

<TABLE BORDER="0" WIDTH="100%">

<TR VALIGN=TOP>

<TD>

<P><FONT SIZE="-2">
   <A HREF="../../relnotes/SMICopyright.html">Copyright &#169;</A> 1997-98
   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>
    All Rights Reserved.</FONT></P>

   <FONT SIZE="-1">
Please send comments to: <a href="mailto:java-security@sun.com">
java-security@sun.com</a>
   </FONT>

</TD>

<TD ALIGN=RIGHT>

   <IMG SRC="../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30>
   <BR>
   <FONT SIZE="+1">
   <i>Java Software</i>
   </FONT>

</TD>

</TR>

</TABLE>

  </body>
</html>
